#first, get a data frame that tells you the total trial counts each subject had
subject_total_trials_df <- check_answer_df %>%
group_by(subject) %>%
summarise(total_trialCounts = max(trialCount))
print(subject_total_trials_df)
#get normalized score for each subject
#normalized_score = (arranged_subject_data_frames$trialCount_accurate) / (subject_total_trials_df$total_trialCounts)
library(dplyr)
# Your original data frames
subject_total_trials_df <- data.frame(
subject = c("a109tuq8wk2vjg", "a11exib1mvbzfj", "a12abieib85r9u", "a12d8yonw8tywu", "a12t55b08jjyyv"),
total_trialCounts = c(4, 4, 5, 5, 4)
)
modified_merged_object_df <- data.frame(
subject = c("a109tuq8wk2vjg", "a109tuq8wk2vjg", "a11exib1mvbzfj", "a11exib1mvbzfj", "a12abieib85r9u"),
trialCount_accurate = c(2, 2, 2, 2, 2),
slot_key = c("slot0", "slot1", "slot0", "slot1", "slot0")
)
# Join the two data frames based on 'subject'
merged_df_5 <- modified_merged_object_df %>%
left_join(subject_total_trials_df, by = "subject")
# Calculate the 'score' as trialCount_accurate divided by total_trialCounts
merged_df_5 <- merged_df_5 %>%
mutate(score = trialCount_accurate / total_trialCounts)
# Select the columns you want in the final data frame
new_df_5 <- merged_df_5 %>%
select(subject, slot_key, score, object_type)
# Print the new data frame
print(new_df_5)
#get normalized score for each subject
#normalized_score = (arranged_subject_data_frames$trialCount_accurate) / (subject_total_trials_df$total_trialCounts)
library(dplyr)
# Your original data frames
subject_total_trials_df <- data.frame(
subject = c("a109tuq8wk2vjg", "a11exib1mvbzfj", "a12abieib85r9u", "a12d8yonw8tywu", "a12t55b08jjyyv"),
total_trialCounts = c(4, 4, 5, 5, 4)
)
modified_merged_object_df <- data.frame(
subject = c("a109tuq8wk2vjg", "a109tuq8wk2vjg", "a11exib1mvbzfj", "a11exib1mvbzfj", "a12abieib85r9u"),
trialCount_accurate = c(2, 2, 2, 2, 2),
slot_key = c("slot0", "slot1", "slot0", "slot1", "slot0")
)
# Join the two data frames based on 'subject'
merged_df_5 <- modified_merged_object_df %>%
left_join(subject_total_trials_df, by = "subject")
# Calculate the 'score' as trialCount_accurate divided by total_trialCounts
merged_df_5 <- merged_df_5 %>%
mutate(score = trialCount_accurate / total_trialCounts)
# Select the columns you want in the final data frame
new_df_5 <- merged_df_5 %>%
select(subject, slot_key, score)
# Print the new data frame
print(new_df_5)
print(subject_total_trials_df)
library(tidyverse)
library(psycho)
library(dplyr)
check_answer_df
#make a new df that has the columns 'subject', 'slot_key', and 'correct_object' so that you have a record of which slot corresponds to which
slot_key_df <- check_answer_df %>%
select('subject', 'slot0CorrectType', 'slot0CorrectSRC', 'slot1CorrectType', 'slot1CorrectSRC', 'slot2CorrectType', 'slot2CorrectSRC',
'slot3CorrectType', 'slot3CorrectSRC', 'slot4CorrectType', 'slot4CorrectSRC', 'slot5CorrectType', 'slot5CorrectSRC', 'slot6CorrectType',
'slot6CorrectSRC', 'slot7CorrectType', 'slot7CorrectSRC', 'slot8CorrectType', 'slot8CorrectSRC', 'slot9CorrectType', 'slot9CorrectSRC') %>%
filter(!duplicated(subject))
slot_key_df
new_slot_key_1_df <- slot_key_df %>%
select(c('subject', ends_with("CorrectSRC"))) %>%
pivot_longer(cols = starts_with("slot"), names_to = 'slot_key', values_to = 'correct_pic') %>%
mutate(slot_key = substr(slot_key, 1, 5))
new_slot_key_1_df
new_slot_key_2_df <- slot_key_df %>%
select(c('subject', ends_with("CorrectType"))) %>%
pivot_longer(cols = starts_with("slot"), names_to = 'slot_key', values_to = 'correct_type') %>%
mutate(slot_key = substr(slot_key, 1, 5))
new_slot_key_2_df
new_slot_key_combined_df <- new_slot_key_1_df %>%
full_join(new_slot_key_2_df, by=c('subject', 'slot_key')) %>%
mutate(correct_object = paste(correct_pic, correct_type, sep = "_")) %>%
select('subject', 'slot_key', 'correct_object')
new_slot_key_combined_df
###now, we need to combine that with what we got before as in the 'subject', 'trial when it was accurate', and 'image by slot'
check_answer_df
check_answer_df_1 <- check_answer_df %>%
group_by(subject) %>%
slice(1)
check_answer_df_1
#MANIPULATE THE DATA FRAME SO IT IS IN THE DESIRED FORMAT
library(dplyr)
library(stringr)
accuracy_df_list
# ... Your previous code ...
# Create an empty data frame to store the combined results
combined_df <- data.frame(subject = character(),
trialCount_accurate = numeric(),
slot_key = character(),
stringsAsFactors = FALSE)
# Iterate over each data frame in accuracy_df_list
for (i in seq_along(accuracy_df_list)) {
df <- accuracy_df_list[[i]]
subject <- df$subject[1]  # Get the subject name
# Iterate over the columns starting from the third column
for (col in colnames(df)[3:length(df)]) {
image <- col  # Get the column name
row_index <- which(df[[col]] == 100)[1]  # Find the first row index where the value is 100
if (!is.na(row_index)) {  # Check if a row with 100% accuracy exists
# Get the value for 'trialCount' in the same row index
trial_count_accurate <- df$trialCount[row_index]
# Modify the 'image' column value
slot_key <- str_remove(image, "accuracy_")
# Append a new row to the combined data frame
new_row <- data.frame(subject = subject,
trialCount_accurate = trial_count_accurate,
slot_key = slot_key,
stringsAsFactors = FALSE)
combined_df <- rbind(combined_df, new_row)
}
}
}
# Print the combined data frame
print(combined_df)
#once we have this data frame with the columns 'subject', 'trialCount_accurate' (the trial count the subject first got that slot key 100% right the first time), and 'slot_key' (like slot0, slot1, etc.),
#we need to now change slot_key such that it is telling us the image & image type rather than the slot for each subject.
merged_correct_object_df <- combined_df %>%
full_join(new_slot_key_combined_df, by=c('subject', 'slot_key'))
merged_correct_object_df
#yay! we got what we wanted with columns 'subject', 'trialCount_accurate', 'slot_key', and 'correct_object' (can use select to eliminate slot_key if you want later)
#Now, option to make it a list of data frames by subject:
#next step is to compare threat versus neutral I guess. So for each subject, will have to find the trialCount_accurate for threat averaged and trialCount_accurate for neutral averaged
#might be helpful to graph it first, and then do t-test and such so you know exactly what to compare, can also look at old drag and drop stuff
#can look at old code for comparisons on doing it between vs. within subject comparisons
#add column object_type that tells if object was threat or neutral for comparisons
modified_merged_object_df <- merged_correct_object_df %>%
mutate(object_type = str_extract(correct_object, "(?<=_)\\w+$"))
modified_merged_object_df
#statistical testing
mean_rank_score_df <- modified_merged_object_df %>%
group_by(object_type) %>%
summarize(mean_score = mean(trialCount_accurate))
mean_rank_score_df
#t.test(modified_merged_object_df$trialCount_accurate ~ modified_merged_object_df$object_type, mu = 0,
# alternative = "greater",
# paired = TRUE,
#var.equal = FALSE,
#conf.level = 0.95)
#ORGANIZE THE RANK ORDERS THE WAY YOU WANT TO, SPLIT BASED ON SUBJECT
# Split the data frame into a list of data frames by 'subject'
subject_data_frames <- merged_correct_object_df %>%
split(.$subject)
# Define a function to arrange each data frame within the list
arrange_and_filter <- function(df) {
df %>%
arrange(trialCount_accurate)
}
# Apply the function to each data frame in the list
arranged_subject_data_frames <- lapply(subject_data_frames, arrange_and_filter)
arranged_subject_data_frames
#NORMALIZED VERSION
#first, get a data frame that tells you the total trial counts each subject had
subject_total_trials_df <- check_answer_df %>%
group_by(subject) %>%
summarise(total_trialCounts = max(trialCount))
print(subject_total_trials_df)
print(combined_df)
# Merge the two data frames by the 'subject' column
final_merged_df <- merge(combined_df, subject_total_trials_df, by = 'subject')
# Print the final merged data frame
print(final_merged_df)
normalized_merged_df <- final_merged_df %>%
mutate(normalized_score = (trialCount_accurate) / (total_trialCounts))
normalizzed_merged_df
normalized_merged_df <- final_merged_df %>%
mutate(normalized_score = (trialCount_accurate) / (total_trialCounts))
normalized_merged_df
View(normalized_merged_df)
result_df_to_send <- result_df %>%
filter(subject ! = 'a109tuq8wk2vjg')
result_df_to_send
result_df_to_send <- result_df %>%
filter(subject != 'a109tuq8wk2vjg')
result_df_to_send
library(tidyverse)
library(psycho)
library(dplyr)
check_answer_df
#make a new df that has the columns 'subject', 'slot_key', and 'correct_object' so that you have a record of which slot corresponds to which
slot_key_df <- check_answer_df %>%
select('subject', 'slot0CorrectType', 'slot0CorrectSRC', 'slot1CorrectType', 'slot1CorrectSRC', 'slot2CorrectType', 'slot2CorrectSRC',
'slot3CorrectType', 'slot3CorrectSRC', 'slot4CorrectType', 'slot4CorrectSRC', 'slot5CorrectType', 'slot5CorrectSRC', 'slot6CorrectType',
'slot6CorrectSRC', 'slot7CorrectType', 'slot7CorrectSRC', 'slot8CorrectType', 'slot8CorrectSRC', 'slot9CorrectType', 'slot9CorrectSRC') %>%
filter(!duplicated(subject))
slot_key_df
new_slot_key_1_df <- slot_key_df %>%
select(c('subject', ends_with("CorrectSRC"))) %>%
pivot_longer(cols = starts_with("slot"), names_to = 'slot_key', values_to = 'correct_pic') %>%
mutate(slot_key = substr(slot_key, 1, 5))
new_slot_key_1_df
new_slot_key_2_df <- slot_key_df %>%
select(c('subject', ends_with("CorrectType"))) %>%
pivot_longer(cols = starts_with("slot"), names_to = 'slot_key', values_to = 'correct_type') %>%
mutate(slot_key = substr(slot_key, 1, 5))
new_slot_key_2_df
new_slot_key_combined_df <- new_slot_key_1_df %>%
full_join(new_slot_key_2_df, by=c('subject', 'slot_key')) %>%
mutate(correct_object = paste(correct_pic, correct_type, sep = "_")) %>%
select('subject', 'slot_key', 'correct_object')
new_slot_key_combined_df
###now, we need to combine that with what we got before as in the 'subject', 'trial when it was accurate', and 'image by slot'
check_answer_df
check_answer_df_1 <- check_answer_df %>%
group_by(subject) %>%
slice(1)
check_answer_df_1
#MANIPULATE THE DATA FRAME SO IT IS IN THE DESIRED FORMAT
library(dplyr)
library(stringr)
accuracy_df_list
# ... Your previous code ...
# Create an empty data frame to store the combined results
combined_df <- data.frame(subject = character(),
trialCount_accurate = numeric(),
slot_key = character(),
stringsAsFactors = FALSE)
# Iterate over each data frame in accuracy_df_list
for (i in seq_along(accuracy_df_list)) {
df <- accuracy_df_list[[i]]
subject <- df$subject[1]  # Get the subject name
# Iterate over the columns starting from the third column
for (col in colnames(df)[3:length(df)]) {
image <- col  # Get the column name
row_index <- which(df[[col]] == 100)[1]  # Find the first row index where the value is 100
if (!is.na(row_index)) {  # Check if a row with 100% accuracy exists
# Get the value for 'trialCount' in the same row index
trial_count_accurate <- df$trialCount[row_index]
# Modify the 'image' column value
slot_key <- str_remove(image, "accuracy_")
# Append a new row to the combined data frame
new_row <- data.frame(subject = subject,
trialCount_accurate = trial_count_accurate,
slot_key = slot_key,
stringsAsFactors = FALSE)
combined_df <- rbind(combined_df, new_row)
}
}
}
# Print the combined data frame
print(combined_df)
#once we have this data frame with the columns 'subject', 'trialCount_accurate' (the trial count the subject first got that slot key 100% right the first time), and 'slot_key' (like slot0, slot1, etc.),
#we need to now change slot_key such that it is telling us the image & image type rather than the slot for each subject.
merged_correct_object_df <- combined_df %>%
full_join(new_slot_key_combined_df, by=c('subject', 'slot_key'))
merged_correct_object_df
#yay! we got what we wanted with columns 'subject', 'trialCount_accurate', 'slot_key', and 'correct_object' (can use select to eliminate slot_key if you want later)
#Now, option to make it a list of data frames by subject:
#next step is to compare threat versus neutral I guess. So for each subject, will have to find the trialCount_accurate for threat averaged and trialCount_accurate for neutral averaged
#might be helpful to graph it first, and then do t-test and such so you know exactly what to compare, can also look at old drag and drop stuff
#can look at old code for comparisons on doing it between vs. within subject comparisons
#add column object_type that tells if object was threat or neutral for comparisons
modified_merged_object_df <- merged_correct_object_df %>%
mutate(object_type = str_extract(correct_object, "(?<=_)\\w+$"))
modified_merged_object_df
#statistical testing
mean_rank_score_df <- modified_merged_object_df %>%
group_by(object_type) %>%
summarize(mean_score = mean(trialCount_accurate))
mean_rank_score_df
#t.test(modified_merged_object_df$trialCount_accurate ~ modified_merged_object_df$object_type, mu = 0,
# alternative = "greater",
# paired = TRUE,
#var.equal = FALSE,
#conf.level = 0.95)
#ORGANIZE THE RANK ORDERS THE WAY YOU WANT TO, SPLIT BASED ON SUBJECT
# Split the data frame into a list of data frames by 'subject'
subject_data_frames <- merged_correct_object_df %>%
split(.$subject)
# Define a function to arrange each data frame within the list
arrange_and_filter <- function(df) {
df %>%
arrange(trialCount_accurate)
}
# Apply the function to each data frame in the list
arranged_subject_data_frames <- lapply(subject_data_frames, arrange_and_filter)
arranged_subject_data_frames
#NORMALIZED VERSION
#first, get a data frame that tells you the total trial counts each subject had
subject_total_trials_df <- check_answer_df %>%
group_by(subject) %>%
summarise(total_trialCounts = max(trialCount))
print(subject_total_trials_df)
#get normalized score for each subject
#normalized_score = (arranged_subject_data_frames$trialCount_accurate) / (subject_total_trials_df$total_trialCounts)
# Assuming subject_total_trials_df and combined_df are already defined
# Merge the two data frames by the 'subject' column so that you have trialCount_accurate and total_trialCounts in the same df
final_merged_df <- merge(combined_df, subject_total_trials_df, by = 'subject')
print(final_merged_df)
normalized_merged_df <- final_merged_df %>%
mutate(normalized_score = (trialCount_accurate) / (total_trialCounts))
normalized_merged_df
#####
### get
library(dplyr)
library(purrr)
# Assuming your list of data frames is named arranged_subject_data_frames
# and subject total trial counts are stored in subject_total_trials_df
# Also assuming the modified_merged_object_df has a 'subject' and 'correct_object' column
# Define a function to calculate normalized scores
calculate_normalized_score <- function(subject_df, total_trials) {
normalized_score <- subject_df$trialCount_accurate / total_trials
return(normalized_score)
}
# Map the function across each subject's data frame
normalized_scores <- map2(
arranged_subject_data_frames,
subject_total_trials_df$total_trialCounts,
calculate_normalized_score
)
# Combine normalized scores into a data frame
normalized_scores_df <- bind_rows(
map2_df(names(arranged_subject_data_frames), normalized_scores, ~ data.frame(subject = .x, normalized_score = .y))
) %>%
group_by(subject) %>%
summarize(normalized_score = mean(normalized_score)) # Summarize to get max (or mean?) score per subject - this part i'm iffy about
# Merge with modified_merged_object_df by subject
result_df <- modified_merged_object_df %>%
left_join(normalized_scores_df, by = "subject")
# Print the merged result data frame
print(result_df)
result_df_to_send <- result_df %>%
filter(subject != 'a109tuq8wk2vjg')
result_df_to_send
normalized_merged_df
normalized_merged_df
normalized_merged_to_send_df <- normalized_merged_df %>%
filter(subject != 'a109tuq8wk2vjg')
normalized_merged_to_send_df
View(normalized_merged_to_send_df)
modified_merged_object_df
combined_df
final_merged_df <- merge(modified_merged_object_df, subject_total_trials_df, by = 'subject')
print(final_merged_df)
normalized_merged_df <- final_merged_df %>%
mutate(normalized_score = (trialCount_accurate) / (total_trialCounts))
normalized_merged_df
#just to send in a screenshot I deleted the first participant because they got it all right on the same trial so not really interesting to look at, disregard after this though
normalized_merged_to_send_df <- normalized_merged_df %>%
filter(subject != 'a109tuq8wk2vjg')
normalized_merged_to_send_df
#statistical testing
mean_normalized_score_df <- normalized_merged_df %>%
group_by(object_type) %>%
summarize(mean_score = mean(normalized_score))
mean_normalized_score_df
t.test(normalized_merged_df$trialCount_accurate ~ normalized_merged_df$object_type, mu = 0,
alternative = "greater"
paired = TRUE,
var.equal = FALSE,
conf.level = 0.95)
t.test(normalized_merged_df$trialCount_accurate ~ normalized_merged_df$object_type, mu = 0,
alternative = "greater",
paired = TRUE,
var.equal = FALSE,
conf.level = 0.95)
library(tidyverse)
library(psycho)
library(dplyr)
check_answer_df
#make a new df that has the columns 'subject', 'slot_key', and 'correct_object' so that you have a record of which slot corresponds to which
slot_key_df <- check_answer_df %>%
select('subject', 'slot0CorrectType', 'slot0CorrectSRC', 'slot1CorrectType', 'slot1CorrectSRC', 'slot2CorrectType', 'slot2CorrectSRC',
'slot3CorrectType', 'slot3CorrectSRC', 'slot4CorrectType', 'slot4CorrectSRC', 'slot5CorrectType', 'slot5CorrectSRC', 'slot6CorrectType',
'slot6CorrectSRC', 'slot7CorrectType', 'slot7CorrectSRC', 'slot8CorrectType', 'slot8CorrectSRC', 'slot9CorrectType', 'slot9CorrectSRC') %>%
filter(!duplicated(subject))
slot_key_df
new_slot_key_1_df <- slot_key_df %>%
select(c('subject', ends_with("CorrectSRC"))) %>%
pivot_longer(cols = starts_with("slot"), names_to = 'slot_key', values_to = 'correct_pic') %>%
mutate(slot_key = substr(slot_key, 1, 5))
new_slot_key_1_df
new_slot_key_2_df <- slot_key_df %>%
select(c('subject', ends_with("CorrectType"))) %>%
pivot_longer(cols = starts_with("slot"), names_to = 'slot_key', values_to = 'correct_type') %>%
mutate(slot_key = substr(slot_key, 1, 5))
new_slot_key_2_df
new_slot_key_combined_df <- new_slot_key_1_df %>%
full_join(new_slot_key_2_df, by=c('subject', 'slot_key')) %>%
mutate(correct_object = paste(correct_pic, correct_type, sep = "_")) %>%
select('subject', 'slot_key', 'correct_object')
new_slot_key_combined_df
###now, we need to combine that with what we got before as in the 'subject', 'trial when it was accurate', and 'image by slot'
check_answer_df
check_answer_df_1 <- check_answer_df %>%
group_by(subject) %>%
slice(1)
check_answer_df_1
#MANIPULATE THE DATA FRAME SO IT IS IN THE DESIRED FORMAT
library(dplyr)
library(stringr)
accuracy_df_list
# ... Your previous code ...
# Create an empty data frame to store the combined results
combined_df <- data.frame(subject = character(),
trialCount_accurate = numeric(),
slot_key = character(),
stringsAsFactors = FALSE)
# Iterate over each data frame in accuracy_df_list
for (i in seq_along(accuracy_df_list)) {
df <- accuracy_df_list[[i]]
subject <- df$subject[1]  # Get the subject name
# Iterate over the columns starting from the third column
for (col in colnames(df)[3:length(df)]) {
image <- col  # Get the column name
row_index <- which(df[[col]] == 100)[1]  # Find the first row index where the value is 100
if (!is.na(row_index)) {  # Check if a row with 100% accuracy exists
# Get the value for 'trialCount' in the same row index
trial_count_accurate <- df$trialCount[row_index]
# Modify the 'image' column value
slot_key <- str_remove(image, "accuracy_")
# Append a new row to the combined data frame
new_row <- data.frame(subject = subject,
trialCount_accurate = trial_count_accurate,
slot_key = slot_key,
stringsAsFactors = FALSE)
combined_df <- rbind(combined_df, new_row)
}
}
}
# Print the combined data frame
print(combined_df)
#once we have this data frame with the columns 'subject', 'trialCount_accurate' (the trial count the subject first got that slot key 100% right the first time), and 'slot_key' (like slot0, slot1, etc.),
#we need to now change slot_key such that it is telling us the image & image type rather than the slot for each subject.
merged_correct_object_df <- combined_df %>%
full_join(new_slot_key_combined_df, by=c('subject', 'slot_key'))
merged_correct_object_df
#yay! we got what we wanted with columns 'subject', 'trialCount_accurate', 'slot_key', and 'correct_object' (can use select to eliminate slot_key if you want later)
#Now, option to make it a list of data frames by subject:
#next step is to compare threat versus neutral I guess. So for each subject, will have to find the trialCount_accurate for threat averaged and trialCount_accurate for neutral averaged
#might be helpful to graph it first, and then do t-test and such so you know exactly what to compare, can also look at old drag and drop stuff
#can look at old code for comparisons on doing it between vs. within subject comparisons
#add column object_type that tells if object was threat or neutral for comparisons
modified_merged_object_df <- merged_correct_object_df %>%
mutate(object_type = str_extract(correct_object, "(?<=_)\\w+$"))
modified_merged_object_df
#statistical testing
mean_rank_score_df <- modified_merged_object_df %>%
group_by(object_type) %>%
summarize(mean_score = mean(trialCount_accurate))
mean_rank_score_df
#t.test(modified_merged_object_df$trialCount_accurate ~ modified_merged_object_df$object_type, mu = 0,
# alternative = "greater",
# paired = TRUE,
#var.equal = FALSE,
#conf.level = 0.95)
#ORGANIZE THE RANK ORDERS THE WAY YOU WANT TO, SPLIT BASED ON SUBJECT
# Split the data frame into a list of data frames by 'subject'
subject_data_frames <- merged_correct_object_df %>%
split(.$subject)
# Define a function to arrange each data frame within the list
arrange_and_filter <- function(df) {
df %>%
arrange(trialCount_accurate)
}
# Apply the function to each data frame in the list
arranged_subject_data_frames <- lapply(subject_data_frames, arrange_and_filter)
arranged_subject_data_frames
#NORMALIZED VERSION
#first, get a data frame that tells you the total trial counts each subject had
subject_total_trials_df <- check_answer_df %>%
group_by(subject) %>%
summarise(total_trialCounts = max(trialCount))
print(subject_total_trials_df)
#get normalized score for each subject
#normalized_score = (arranged_subject_data_frames$trialCount_accurate) / (subject_total_trials_df$total_trialCounts)
# Assuming subject_total_trials_df and combined_df are already defined
# Merge the two data frames by the 'subject' column so that you have trialCount_accurate and total_trialCounts in the same df
final_merged_df <- merge(modified_merged_object_df, subject_total_trials_df, by = 'subject')
print(final_merged_df)
normalized_merged_df <- final_merged_df %>%
mutate(normalized_score = (trialCount_accurate) / (total_trialCounts))
normalized_merged_df
#just to send in a screenshot I deleted the first participant because they got it all right on the same trial so not really interesting to look at, disregard after this though
normalized_merged_to_send_df <- normalized_merged_df %>%
filter(subject != 'a109tuq8wk2vjg')
normalized_merged_to_send_df
#statistical testing
mean_normalized_score_df <- normalized_merged_df %>%
group_by(object_type) %>%
summarize(mean_score = mean(normalized_score))
mean_normalized_score_df
t.test(normalized_merged_df$trialCount_accurate ~ normalized_merged_df$object_type, mu = 0,
alternative = "greater",
paired = TRUE,
var.equal = FALSE,
conf.level = 0.95)
normalized_merged_df
length(normalized_merged_df)
length(normalized_merged_df$trialCount_accurate)
length(normalized_merged_df$object_type)
normalized_merged_df
sum(!complete.cases(normalized_merged_df$trialCount_accurate, normalized_merged_df$object_type))
t.test(normalized_merged_df$normalized_score ~ normalized_merged_df$object_type, mu = 0,
alternative = "greater",
paired = TRUE,
var.equal = FALSE,
conf.level = 0.95)
conf.level = 0.95)
# Check if 'trialCount_accurate' column is numeric
is_numeric <- is.numeric(normalized_merged_df$normalized_score)
# Print the result
print(is_numeric)
# Check if 'trialCount_accurate' column is numeric
is_numeric <- is.numeric(normalized_merged_df$normalized_score)
# Print the result
print(is_numeric)
